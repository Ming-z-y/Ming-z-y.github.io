<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="theme-color" content="#3367D6" />
    <link rel="apple-touch-icon" href="/icons-192.png" />
    <link rel="manifest" href="/manifest.json" />

    <meta name="generator" content="Hexo 6.2.0"> 
    <meta name="description" content="一个前端菜狗的成长之路" />
      
    <meta name="author" content="MINGZhenyous" />
      

    <title>浏览器的基本知识 | MING</title>

      <link rel="shortcut icon" href="/favicon.ico"> 
      
<link rel="stylesheet" href="/css/style.css">

  </head>
  <body>
    <div class="root-container">
      <!-- header container -->
<header class="header-container post">
  
  <div
    class="post-image"
    style="background-image: url(https://pic3.zhimg.com/v2-defa2f2712d4a73b3e19ff5911b5e223_r.jpg?source=1940ef5c)"
  ></div>
   <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
         MING 
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
        <li class="navbar-list-item">
          <a href="/">首页</a>
        </li>
        
        <li class="navbar-list-item">
          <a href="/links">友链</a>
        </li>
        
        <li class="navbar-list-item">
          <a href="/about">关于</a>
        </li>
        
        <li class="navbar-list-item">
          <a href="javascript:;" id="shiftLanguage">切换语言</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

           
  <div class="header-content">
    <div class="post-text layout-block">
      <div class="layout-margin">
        <h1 class="title-wrap">浏览器的基本知识</h1>
        <h2 class="title-sub-wrap">
          <strong>MINGZhenyous</strong>
          <span>发布于</span>
          <time
  class="article-date"
  datetime="2023-03-03T15:35:24.000Z"
  itemprop="datePublished"
  >2023-03-03</time
>

        </h2>
        <ul class="wrap-list dark">
  
    <li><a href="/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/">📒 前端进阶</a></li>
  
</ul> <ul class="wrap-list dark">
  
  <li><a href="/tags/doc/">🏷️ doc</a></li>
  
</ul>

      </div>
    </div>
  </div>
    
</header>
 <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
        
      <section
        class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box"
      >
        <h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><ol>
<li>这节课的内容很多，没有课后作业。</li>
<li>大家每天看一部分，不需要一天看完，一天看完也不好消化</li>
<li>看着部分知识的时候当成课外书来看，因为这是比较底层的一些理论知识，不要求死记硬背，看完理解完就好。多看几遍自然就记住了。</li>
</ol>
<h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其展示在浏览器窗口中，资源通常是 HTML，也包括 PDF，image 及其他格式，用户通过 URI 来指定请求资源的位置。</p>
<h3 id="浏览器主要组件"><a href="#浏览器主要组件" class="headerlink" title="浏览器主要组件"></a>浏览器主要组件</h3><ol>
<li>用户界面 - 包括地址栏、后退&#x2F;前进按钮、书签目录等，也就是你所看到的除了用来显示是你所请求页面主窗口之外的其他部分。</li>
<li>浏览器引擎 - 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎 - 用来显示请求的内容，例如，解析 html 和 css 并将解析后的结果展示出来</li>
<li>网络 - 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>JS 解析器 - 用来解析执行 JS 代码</li>
<li>数据存储 - 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了<code>web database</code>技术，这是一种轻量级完成客户端存储技术</li>
</ol>
<h3 id="本节课会从浏览器的渲染引擎、JS解析器、浏览器缓存三个内容出发去认识浏览器"><a href="#本节课会从浏览器的渲染引擎、JS解析器、浏览器缓存三个内容出发去认识浏览器" class="headerlink" title="本节课会从浏览器的渲染引擎、JS解析器、浏览器缓存三个内容出发去认识浏览器"></a>本节课会从浏览器的<code>渲染引擎</code>、<code>JS解析器</code>、<code>浏览器缓存</code>三个内容出发去认识浏览器</h3><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>通常，我们在编写好 HTML，CSS，Javascript 等文件，经过浏览器就会显示漂亮的页面，但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/79/2b08a85c63bee68c6fd95dabb648fd79.png" alt="img"></p>
<p>从图中可以看出，左边输入的是 HTML，CSS，JavaScript 数据，只写数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>
<p>这中间的渲染模块激素 hi 我们今天讨论的第一个主题。为了更好的理解下文，你可以先结合下图快速抓住 HTML，CSS 和 JavaScript 的含义：</p>
<p><img src="https://static001.geekbang.org/resource/image/31/e6/31cd7172f743193d682d088a60cb44e6.png" alt="img"></p>
<p>从图中可以看出，HTML 内容是由标记和文本组成。标记也成为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确的展示 HTML 内容。比如上面的<code>&lt;p&gt;</code>标签就是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要展示的内容。</p>
<p>如果需要改变 HTML 字体颜色，大小等信息，这就需要用到 CSS。CSS 又称为层叠演示表，是由选择器和属性组成，比如图中的 p 选择器，他会把 HTML 里面的<code>&lt;p&gt;</code>的内容选择出来，然后再把选择器的属性值应用到<code>&lt;p&gt;</code>标签内容上。选择器里面有一个<code>color</code>属性，它的值是 red，这是告诉渲染引擎把<code>&lt;p&gt;</code>标签的内容显示为红色。</p>
<p>至于 JavaScript，使用它可以让页面’’动’’起来，比如上图中，可以通过 JavaScript 来修改 css 样式，从而达到修改文本颜色的目的。</p>
<p>搞清楚 HTML，CSS 和 JavaScript 含义之后，那么接下来就正式开始分析渲染模块，</p>
<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流程线，其大致路程如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png" alt="img"></p>
<p>按照渲染的时间顺序，流水线可以分为下面几个子阶段：构建 DOM 树，样式计算，布局阶段，分层，绘制，分块，光栅化和合成。</p>
<h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 – DOM 树。</p>
<p>这里简单介绍一下什么是树结构，下面是几个例子：</p>
<p><img src="https://static001.geekbang.org/resource/image/fc/38/fcad0a4e3e73c796f00d6120284a3638.png" alt="img"></p>
<p>从图中可以看出，树这种结构非常想我们现实生活中的’’树’’，其中每个点我们成为节点，相连的节点成为父节点。树结构在浏览器中运用还是非常多，下面我们介绍的渲染流程，就是频繁的使用树结构。</p>
<p>接下来我们来看看 DOM 树的构建过程，你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png" alt="img"></p>
<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经过 HTML 解析器解析，最终输出树状结构的 DOM。</p>
<p>为了更加直观地理解 DOM 树，你可以打开 Chrome 地“开发者工具”，选择“Console”标签来打开控制台，然后输入<code>document</code>之后回车，你可以看到一个完整地 DOM 树结构，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png" alt="img"></p>
<p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。</p>
<p>下面就看看如何通过 js 来修改 DOM 内容，在控制台中输入：</p>
<p><code>document.getElementsByTagName(&quot;p&quot;)[0].innerText = &quot;black&quot;</code></p>
<p>这行代码作用就是把第一个<code>&lt;p&gt;</code>标签内容修改为 black，执行结果如下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/74/e730aa1d73c1151c588e2f8c7e22c274.png" alt="img"></p>
<p>从图中可以看出，在执行一段修改第一个<code>&lt;p&gt;</code>标签中 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了</p>
<p>好了，现在已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p>
<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大题可以分为三步来完成</p>
<h5 id="1-把-css-转换为浏览器能够理解的结构"><a href="#1-把-css-转换为浏览器能够理解的结构" class="headerlink" title="1.把 css 转换为浏览器能够理解的结构"></a>1.把 css 转换为浏览器能够理解的结构</h5><p>那 css 样式来源主要有哪些呢？你可以参考下图：</p>
<p><img src="https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png" alt="img"></p>
<p>从图中可以看出，css 样式来源主要有三种：</p>
<ul>
<li><p>通过 link 引用的外部 css 文件</p>
</li>
<li><p><code>&lt;style&gt;</code>标记内的 css</p>
</li>
<li><p>元素的 style 属性内嵌的 css</p>
</li>
<li><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 – styleSheets</p>
</li>
<li><p>为了加深理解，你可以在控制台中输入<code>document.styleSheets</code>，然后你就可以看到下图所示的结构</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png" alt="img"></p>
<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础</p>
<h5 id="2-转换样式表中的属性值，使其标准化"><a href="#2-转换样式表中的属性值，使其标准化" class="headerlink" title="2.转换样式表中的属性值，使其标准化"></a>2.转换样式表中的属性值，使其标准化</h5><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p>
<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本</p>
<pre><code class="css">body &#123;
  font-size: 2em;
&#125;
p &#123;
  color: blue;
&#125;
span &#123;
  display: none;
&#125;
div &#123;
  font-weight: bold;
&#125;
div p &#123;
  color: green;
&#125;
div &#123;
  color: red;
&#125;
</code></pre>
<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>
<p>那标准化后的属性值是什么样子的？</p>
<p><img src="https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png" alt="img"></p>
<p>从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……</p>
<h5 id="3-计算出-DOM-树中每个节点的具体样式"><a href="#3-计算出-DOM-树中每个节点的具体样式" class="headerlink" title="3.计算出 DOM 树中每个节点的具体样式"></a>3.计算出 DOM 树中每个节点的具体样式</h5><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p>
<p><strong>这就涉及到 CSS 的继承规则和层叠规则了。</strong></p>
<p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的</p>
<pre><code class="css">body &#123;
  font-size: 20px;
&#125;
p &#123;
  color: blue;
&#125;
span &#123;
  display: none;
&#125;
div &#123;
  font-weight: bold;
  color: red;
&#125;
div p &#123;
  color: green;
&#125;
</code></pre>
<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png" alt="img"></p>
<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p>
<p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面：</p>
<p><img src="https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png" alt="img"></p>
<p>这个界面展示的信息很丰富，大致可描述为如下</p>
<ul>
<li>首先，可以选择要查看的元素的样式（位于图中的区域 2 中），在图中的第 1 个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是<code>&lt;p&gt;</code>标签，位于<code>html.body.div.</code>这个路径下面</li>
<li>其次，可以从样式来源（位于图中的区域 3 中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。</li>
<li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。</li>
</ul>
<p>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</p>
<p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法</strong>。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习</p>
<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p>
<p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png" alt="img"></p>
<p>上图红色方框中显示了 html.body.div.p 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了。</p>
<h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算</p>
<h5 id="1-构建布局树"><a href="#1-构建布局树" class="headerlink" title="1.构建布局树"></a>1.构建布局树</h5><p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了<code>display:none</code>属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>
<p>我们结合下图来看看布局树的构造过程：</p>
<p><img src="https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png" alt="img"></p>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>
<p>为了构建布局树，浏览器大体上完成了下面这些工作</p>
<ul>
<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；</li>
<li>而不可见的节点会被布局树忽略掉，如<code>head</code>标签下面的全部内容，再比如<code>body.p.span</code>这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li>
</ul>
<h5 id="2-布局计算"><a href="#2-布局计算" class="headerlink" title="2. 布局计算"></a>2. 布局计算</h5><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲。</p>
<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上部分我们介绍了渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</p>
<ul>
<li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li>
<li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li>
<li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。</li>
</ul>
<p>后面渲染流程还有一些其他的知识，这里就不讲了，大家感兴趣的话可以自行百度。</p>
<hr />

<p>下面我们介绍 JS 运行：</p>
<p>前提：<code>v8</code>可以简单理解为运行 <code>js</code> 的一个引擎。</p>
<h4 id="编译器和解析器：V8-如何执行一段-JavaScript-代码的"><a href="#编译器和解析器：V8-如何执行一段-JavaScript-代码的" class="headerlink" title="编译器和解析器：V8 如何执行一段 JavaScript 代码的"></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h4><p>我们站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>
<p>前端工具和框架的自身更新速度非常块，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>
<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念，都是你需要重点关注的。</p>
<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>
<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C&#x2F;C++、GO 等都是编译型语言。</p>
<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>
<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/19.png" alt="img"></p>
<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>
<ol>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>
</ol>
<h4 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h4><p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来“一览全局”，参考下图：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/20.png" alt="img"></p>
<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>
<p><strong>1. 生成抽象语法树（AST）和执行上下文</strong></p>
<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>
<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>
<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>
<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>
<pre><code class="js">var myName = &quot; 极客时间 &quot;;
function foo() &#123;
  return 23;
&#125;
myName = &quot;geektime&quot;;
foo();
</code></pre>
<p>这段代码经过<code>javascript-ast</code>站点处理后，生成的 AST 结构如下：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/21.png" alt="img"></p>
<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>
<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>
<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/22.png" alt="img"></p>
<p>从图中可以看出，通过 var myName &#x3D; “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“&#x3D;”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p>这就是 AST 的生成过程，先分词，再解析。</p>
<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>
<p><strong>2. 生成字节码</strong></p>
<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>
<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>
<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>
<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/23.png" alt="img"></p>
<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>
<p><strong>3. 执行代码</strong></p>
<p>生成字节码之后，接下来就要进入执行阶段了。</p>
<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>
<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>
<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>
<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/24.png" alt="img"></p>
<h4 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h4><p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>
<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>
<ul>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>好了，下面我来总结下今天的内容。</p>
<ul>
<li>首先我们介绍了编译器和解释器的区别。</li>
<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>
<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>
<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。</li>
<li>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</li>
</ul>
<hr>

<h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><blockquote>
<p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。</p>
</blockquote>
<h5 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h5><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242491976-285dbbac-7d90-4d8b-b376-258b507278b4.webp" alt="img"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p>
<h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242491960-f949110c-6293-4bd5-866c-da011bde053f.webp" alt="img"></p>
<p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242492020-b768d28d-3b53-4e58-a7d2-d5bdcc319dd2.webp" alt="img"></p>
<p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242491958-bd9e316f-3455-4c58-90d9-b1a16b6f02b1.webp" alt="img"></p>
<p>那么强制缓存的缓存规则是什么？</p>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires 是 HTTP&#x2F;1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。</p>
<p>Expires 是 HTTP&#x2F;1.0 的字段，但是现在浏览器默认使用的是 HTTP&#x2F;1.1，那么在 HTTP&#x2F;1.1 中网页缓存还是否由 Expires 控制？</p>
<p>到了 HTTP&#x2F;1.1，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 Cache-Control 又是如何控制的呢？</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在 HTTP&#x2F;1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control 的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效</li>
</ul>
<p>了解强制缓存的过程后，我们拓展性的思考一下：</p>
<p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242492340-6d1ae1d4-aa2f-447d-b3ff-59a33a680a8b.webp" alt="img"></p>
<p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size 值则代表该缓存存放的位置，分别为 from memory cache 和 from disk cache。</p>
<p>那么 from memory cache 和 from disk cache 又分别代表的是什么呢？什么时候会使用 from disk cache，什么时候会使用 from memory cache 呢？</p>
<p>from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk。</p>
<p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p>
<p>访问<a target="_blank" rel="noopener" href="https://heyingye.github.io/">https://heyingye.github.io/</a> –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a target="_blank" rel="noopener" href="https://heyingye.github.io/">https://heyingye.github.io/</a> –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p>
<p>过程如下：</p>
<ul>
<li>访问<a target="_blank" rel="noopener" href="https://heyingye.github.io/![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493580-8dc3b26f-d54b-45cf-8bb8-4b9774a495cc.webp)">https://heyingye.github.io/![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493580-8dc3b26f-d54b-45cf-8bb8-4b9774a495cc.webp)</a></li>
<li>关闭博客的标签页</li>
<li>重新打开<a target="_blank" rel="noopener" href="https://heyingye.github.io/![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493625-300b85e5-3a63-4d82-afbe-53e7305ccf0a.webp)">https://heyingye.github.io/![img](https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493625-300b85e5-3a63-4d82-afbe-53e7305ccf0a.webp)</a></li>
<li>刷新<img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493678-668db2d9-d153-48be-9db7-ccfee0fba26e.webp" alt="img"> from disk memory</li>
</ul>
<p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着 from disk cache 和 from memory cache 吗？</p>
<p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p>
<ul>
<li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li>
<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li>
<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>
<li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I&#x2F;O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li>
</ul>
<p>在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p>协商缓存生效，返回 304，如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493276-dcd14cfe-3ef8-46cd-92c1-00b5b8197820.webp" alt="img"> 304</p>
<p>协商缓存失效，返回 200 和请求结果结果，如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242493513-96e7b882-1b61-4295-bd27-27afbfb69ccf.webp" alt="img"> 200</p>
<p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。</p>
<h5 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h5><p>Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494025-d3f1b128-4991-4510-9cad-c9dda1bd1769.webp" alt="img"> last-modify</p>
<p>If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件，如下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494349-615c7e3e-8f39-418e-a06a-fb793fd85475.webp" alt="img"> If-Modified-Since</p>
<h5 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h5><p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494338-78986e87-0d48-419e-9336-677091895deb.webp" alt="img"> Etag</p>
<p>If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200，如下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494501-0e2fa50b-73cb-4033-9df5-9526fd259c46.webp" alt="img"> Etag-match</p>
<p>注：Etag &#x2F; If-None-Match 优先级高于 Last-Modified &#x2F; If-Modified-Since，同时存在则只有 Etag &#x2F; If-None-Match 生效。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存，主要过程如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/573640/1619242494623-5e22c25c-7fef-4568-b970-69dfd58199dd.webp" alt="img"></p>

      </section>

       
      <nav class="article-nav">
          <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="https://ts1.cn.mm.bing.net/th/id/R-C.d0a85a22869d1a62e6364759328789c7?rik=C8AhRipi084U8A&amp;riu=http%3a%2f%2fimg.ewebweb.com%2fuploads%2f20191203%2f16%2f1575360827-LZhYDmiwGV.jpg&amp;ehk=RO1zX4%2fLTfv7KNwSIEYVovYXmKRAvyPqlz4zxIGO9sM%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0"></div>
    
    <div class="card-text">
      
        <a href="/2022/09/23/%E5%86%8D%E5%AD%A6Node/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">重学 Node</h2>
        </a>
      
      <div class="card-text--row">前の記事</div>
    </div>
  </article>
</div> 
      </nav>
      

      <section class="page-message-container layout-padding">
              

      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="/images/avatar.png" class="soft-size--round soft-style--box" alt="Mr.MING">
    
    
      <h2>Mr.MING</h2>
    
    
      <p>Practice makes perfect</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>11</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        3
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        2
      </div>
    </div>
  </div>
</section>   <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%AE%97%E6%B3%95/">
            算法 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E8%AE%A1%E7%BD%91/">
            计网 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/">
            前端进阶 (2)
          </a>
        </li>
      
    </ul>
  </div>
</section> <section
  class="widget-tags widget-item layout-margin content-padding--primary soft-size--large soft-style--box"
>
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/daily/" style="font-size: 10px;" class="tags-cloud-0">daily</a> <a href="/tags/doc/" style="font-size: 20px;" class="tags-cloud-10">doc</a>
    </div>
  </div>
</section>

    </div>
  </article>
</div>
 <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
             
      <a
        href="https://github.com/Ming-z-y/"
        class="soft-size--primary soft-style--box"
        target="_blank"
        rel="noopener noreferrer"
      >
        <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
      </a>
        
      <a
        href="https://twitter.com/guanquanhong"
        class="soft-size--primary soft-style--box"
        target="_blank"
        rel="noopener noreferrer"
      >
        <svg class="icon icon-twitter" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571 0.571429 8 0.571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143 0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429 0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429 0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571l0-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714 0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"></path>
</svg>
      </a>
       
    </div>
    
    <p>
      &copy; 2023
      <a href="/" target="_blank">MINGZhenyous</a>
    </p>

    

    <p>
      Powered by
      <a href="https://hexo.io" target="_blank" rel="noopener noreferrer"
        >Hexo</a
      >
      Theme -
      <a
        href="https://github.com/miiiku/flex-block"
        target="_blank"
        rel="noopener noreferrer author"
        >flex-block</a
      >
    </p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>

    </div>

    <div class="back-to-top-fixed soft-size--round soft-style--box">
      <svg
        class="icon icon-back-to-top"
        viewBox="0 0 1024 1024"
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"
        ></path>
        <path
          d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"
        ></path>
        <path
          d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"
        ></path>
      </svg>
    </div>

     <!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/js/script.js"></script>

  <!-- 尾部用户自定义相关内容 -->
  </body>
</html>
